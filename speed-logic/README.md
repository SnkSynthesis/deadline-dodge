# Speed Logic

This circuitry controls the speed of the [lfsr-decoder-logic](../lfsr-decoder-logic/) and, in turn, how fast the rocks fall in the game. It is a modular feature that introduces three distinct speed levels.

As the game goes forward, the logic increases the speed at which rocks spawn and fall, making the game progressively harder.

## Operation

### Triggering the Speed Increase
An AND gate detects the LFSR state 1111 (inputs: Qa, Qb, Qc, Qd), which occurs at regular intervals. This output increments a mod-6 counter (74LS163N). Although the counter is designed to count up to 6, it is forced to jump to its maximum count (1111) in order to set the RCO pin high, triggering the next stage. While any mod-n counter could have been used, we selected a mod-6 counter because it offered the most suitable time spacing between the three modes. As a result, the game speed increases after the LFSR enters the 1111 state six times.
#### How the counter works:
The counter begins at 0001 and continues its count to 0011, where the NAND-gate-to-LOAD goes low and triggers the LOAD pin (on the '163N IC), making the counter jump to count 1100, (see [Timing Diagram For Jump](./Timing_For_Jump.png)). Then the counter continues its count. The counter's RCO pin goes high when the counter reaches 1111 and rolls over. The RCO pin triggers the next stage.  

### Speed Level Control
The next stage is another 74LS163N counter. Each time the RCO pin goes high on the previous stage, this counter is incremented and the game speed increases. Once the second-stage-counter is inremented it must wait for the first-stage-counter's RCO pin to go high before it increments again. See [RCO Speed Increase Diagram](./RCO_Speed_Increase_Diagram.png). After two speed increases, this counter continues to count up, but combinational logic downstream makes all counts 0010 and above lock the game at its highest speed setting. 

### Speed Selection and Distribution
The counterâ€™s outputs are decoded with combinational logic to control a 74LS153 4-to-1 multiplexer (MUX).

The MUX selects between three clock inputs:
* System clock (full speed)
* Divide-by-2 clock (medium speed)
* Divide-by-4 clock (low speed)

The two divided clocks are generated by using a counter as a frequency divider (divides by factor of 2 for each output bit).

The MUX output determines the active game speed. This clock signal is fed back into the rest of the game except for the [player-movement-logic](../player-movement-logic) and [collision-logic](../collision-logic) (system clock is needed for optimal responsiveness), so that all elements operate in sync with the selected tempo.

## Schematic
![Speed Logic Schematic](Speed_Logic_Schematic.png)

_Screenshot of Speed_Logic.ms14_
